<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Snooker V1.0.5</title>
    <style>
        /* --- CSS 樣式區域 (V1.0.5) --- */
        body {
            margin: 0;
            padding: 0;
            background-color: #121212;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #1a1a1a;
        }

        canvas {
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            border-radius: 4px; /* 邊角稍微銳利一點 */
            cursor: crosshair;
        }

        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* 記分板 */
        #scoreboard {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 70%;
            max-width: 500px;
            height: 55px;
            background: linear-gradient(to bottom, #2c3e50, #000);
            border-bottom-left-radius: 12px;
            border-bottom-right-radius: 12px;
            border: 1px solid #444;
            border-top: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.6);
            pointer-events: auto;
            color: #fff;
            z-index: 10;
        }

        .player-info { display: flex; flex-direction: column; align-items: center; width: 80px; }
        .player-name { font-size: 12px; color: #aaa; margin-bottom: 2px; }
        .score-val { font-size: 24px; font-weight: bold; color: #fff; line-height: 1; }
        
        #frame-info {
            display: flex; flex-direction: column; align-items: center;
            background: #111; padding: 2px 15px; border-radius: 6px;
            border: 1px solid #555; min-width: 90px;
        }
        #frame-label { font-size: 10px; color: #888; text-transform: uppercase; letter-spacing: 1px; }
        #frame-score { font-size: 18px; color: #ffd700; font-weight: bold; }

        .active-p1 .player-info:first-child .score-val { color: #ffd700; text-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
        .active-p2 .player-info:last-child .score-val { color: #ffd700; text-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }

        /* 力道條 */
        #power-bar-container {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            width: 24px;
            height: 200px;
            background: #222;
            border: 2px solid #555;
            border-radius: 12px;
            pointer-events: auto;
            overflow: hidden;
            z-index: 20;
        }
        #power-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 50%;
            background: linear-gradient(to top, #2ecc71, #f1c40f, #e74c3c);
            transition: height 0.1s linear;
        }
        #power-label {
            position: absolute;
            right: 45px;
            top: 50%;
            transform: translateY(-50%);
            color: rgba(255,255,255,0.4);
            font-size: 10px;
            writing-mode: vertical-rl;
            letter-spacing: 3px;
        }

        /* SHOOT 按鈕 */
        #fire-btn {
            position: absolute;
            right: 50px;
            bottom: 20%;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: radial-gradient(circle, #e74c3c, #c0392b);
            border: 3px solid #fff;
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.6);
            color: white;
            font-weight: bold;
            font-size: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto;
            transition: transform 0.1s, opacity 0.2s;
            opacity: 0.5;
            pointer-events: none;
            user-select: none;
            z-index: 20;
        }
        #fire-btn.ready {
            opacity: 1;
            pointer-events: auto;
            animation: pulse 2s infinite;
        }
        #fire-btn:active { transform: scale(0.95); }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(231, 76, 60, 0); }
            100% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0); }
        }

        /* V1.0.5 重設按鈕: 改為「重新擺球」 */
        #reset-cue-btn {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(50, 50, 50, 0.8);
            color: #ddd;
            border: 1px solid #777;
            padding: 8px 20px;
            border-radius: 20px;
            cursor: pointer;
            pointer-events: auto;
            display: none; /* 預設隱藏，瞄準時顯示 */
            font-size: 13px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            z-index: 50;
            transition: background 0.2s;
        }
        #reset-cue-btn:hover { background: rgba(80, 80, 80, 0.9); color: #fff; }

        /* 控制按鈕 */
        #info-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 32px;
            height: 32px;
            background: #444;
            color: white;
            border: 1px solid #777;
            border-radius: 50%;
            font-family: serif; font-weight: bold; font-size: 18px;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer; pointer-events: auto;
            z-index: 30;
        }

        #controls-bottom {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 60px;
            pointer-events: auto;
        }
        .adjust-btn {
            width: 50px; height: 50px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            color: white; font-size: 20px;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer; transition: background 0.1s;
        }
        .adjust-btn:active { background: rgba(255, 255, 255, 0.3); }

        #status-msg {
            position: absolute;
            bottom: 85px;
            left: 50%;
            transform: translateX(-50%);
            color: #eee;
            background: rgba(0,0,0,0.7);
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 13px;
            pointer-events: none;
            white-space: nowrap;
            z-index: 15;
            transition: color 0.3s;
        }

        /* Modal */
        #modal-overlay {
            display: none;
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            justify-content: center; align-items: center;
            pointer-events: auto;
        }
        #modal-content {
            background: #f5f5f5; color: #222;
            width: 340px; max-height: 80vh; overflow-y: auto;
            padding: 20px; border-radius: 10px;
            box-shadow: 0 0 25px rgba(0,0,0,0.7);
        }
        #modal-content h2 { margin-top: 0; border-bottom: 2px solid #333; padding-bottom: 10px; font-size: 20px;}
        
        details.version-block {
            margin-bottom: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: #fff;
            overflow: hidden;
            text-align: left;
        }
        details[open] { background: #e8f0fe; border-color: #4285f4; }
        
        summary.version-title {
            font-weight: bold;
            cursor: pointer;
            padding: 10px;
            outline: none;
            list-style: none;
            background: #eee;
        }
        summary.version-title:hover { background: #e0e0e0; }
        details[open] summary.version-title { background: #d2e3fc; color: #1967d2; }
        summary.version-title::-webkit-details-marker { display: none; }
        summary.version-title::after { content: "+"; float: right; font-weight: normal; color: #666; }
        details[open] summary.version-title::after { content: "-"; }
        .version-list { margin: 10px 0 10px 20px; padding-right: 10px; font-size: 13px; line-height: 1.6; color: #333; }
        #modal-close {
            margin-top: 15px; padding: 10px; background: #333; color: white;
            border: none; border-radius: 5px; cursor: pointer; width: 100%; font-weight: bold;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="snookerCanvas"></canvas>
        
        <div class="ui-layer">
            <div id="scoreboard">
                <div class="player-info">
                    <span class="player-name">Player 1</span>
                    <span id="p1-score" class="score-val">0</span>
                </div>
                <div id="frame-info">
                    <span id="frame-label">FRAMES</span>
                    <span id="frame-score">0 - 0</span>
                </div>
                <div class="player-info">
                    <span class="player-name">Player 2</span>
                    <span id="p2-score" class="score-val">0</span>
                </div>
            </div>

            <div id="info-btn">i</div>
            <div id="fire-btn">SHOOT</div>
            
            <!-- V1.0.5: 文字修改為重新擺球 -->
            <button id="reset-cue-btn">↩️ 重新擺球</button>

            <div id="power-bar-container">
                <div id="power-fill"></div>
            </div>
            <div id="power-label">POWER</div>

            <div id="status-msg">Vibe Snooker V1.0.5</div>

            <div id="controls-bottom">
                <div class="adjust-btn" id="btn-left">&lt;</div>
                <div class="adjust-btn" id="btn-right">&gt;</div>
            </div>
        </div>
    </div>

    <!-- Modal -->
    <div id="modal-overlay">
        <div id="modal-content">
            <h2>Snooker 版本資訊</h2>
            
            <!-- V 1.0.5 -->
            <details class="version-block" open>
                <summary class="version-title">Version 1.0.5 (最新)</summary>
                <ul class="version-list">
                    <li><strong>進球判定重寫:</strong> 球在袋口附近時關閉庫邊碰撞，解決球被彈出問題。</li>
                    <li><strong>庫邊調整:</strong> 厚度減薄至標準比例，提升視覺與可玩性。</li>
                    <li><strong>球速與手感:</strong> 降低擊球速度(動畫變慢)，減少摩擦力(滾更遠)，模擬真實檯泥。</li>
                    <li><strong>規則修正:</strong> 綠/黃球位置改為 D 區角落；移除紅球與粉球間隙。</li>
                    <li><strong>擺球優化:</strong> 「重新擺球」按鈕改為擺球確認後出現，可隨時反悔重擺。</li>
                </ul>
            </details>

            <details class="version-block">
                <summary class="version-title">Version 1.0.4</summary>
                <ul class="version-list">
                    <li>預設力量 50%。</li>
                    <li>碰撞邏輯初步優化。</li>
                </ul>
            </details>
            <details class="version-block">
                <summary class="version-title">Version 1.0.3</summary>
                <ul class="version-list">
                    <li>袋口寬度調整。</li>
                    <li>手風琴式選單。</li>
                </ul>
            </details>
            <details class="version-block">
                <summary class="version-title">Version 1.0.2</summary>
                <ul class="version-list">
                    <li>獨立擊球按鈕 (SHOOT)。</li>
                    <li>瞄準線動態顯示。</li>
                </ul>
            </details>
            <details class="version-block">
                <summary class="version-title">Version 1.0.1</summary>
                <ul class="version-list">
                    <li>修正 Cushion 物理反彈。</li>
                    <li>長條型記分板。</li>
                </ul>
            </details>
            <button id="modal-close">關閉</button>
        </div>
    </div>

    <script>
        /**
         * Vibe Snooker V1.0.5
         * 修正進球物理、庫邊厚度、動畫速度、擺球規則與重設邏輯
         */

        // --- 常數配置 ---
        const TABLE_WIDTH_BASE = 800;
        const TABLE_HEIGHT_BASE = 400;
        
        const BALL_RADIUS = 7;
        
        // V1.0.5: 袋口半徑設為 22 (球直徑 14 的約 1.6 倍)
        // 配合新的「忽略庫邊」邏輯，這大小很剛好
        const POCKET_RADIUS = 22; 
        
        // V1.0.5: 庫邊改薄，視覺更像真實球桌 (原 25 -> 16)
        const RAIL_SIZE = 16; 
        
        const D_LINE_X = TABLE_WIDTH_BASE * 0.2;
        const D_ARC_RADIUS = 60; 

        // 物理參數
        // V1.0.5: 摩擦力調高 (數值接近1)，讓球滾更久 (原 0.975 -> 0.988)
        // 配合極低的速度係數，創造「慢速但長距離」的滾動感
        const FRICTION = 0.988; 
        const STOP_THRESHOLD = 0.03;
        const CUSHION_RESTITUTION = 0.8; 
        
        // V1.0.5: 大幅降低力道係數，解決「動畫太快」問題 (原 0.33 -> 0.18)
        const FORCE_MULTIPLIER = 0.18;

        const COLORS = {
            FELT: '#2a7c45',
            RAIL: '#3e2211', // 稍微深一點的木頭色
            POCKET: '#080808',
            GUIDE_CUE: '#ffffff',
            GUIDE_TARGET: '#ffff00', 
            CUE_STICK: '#d2b48c'
        };

        const BALL_TYPES = {
            WHITE:  { color: '#ffffff', points: 4, type: 'cue' },
            RED:    { color: '#cc0000', points: 1, type: 'red' },
            YELLOW: { color: '#eebb00', points: 2, type: 'color', value: 2 },
            GREEN:  { color: '#006600', points: 3, type: 'color', value: 3 },
            BROWN:  { color: '#996633', points: 4, type: 'color', value: 4 },
            BLUE:   { color: '#0000cc', points: 5, type: 'color', value: 5 },
            PINK:   { color: '#ff6699', points: 6, type: 'color', value: 6 },
            BLACK:  { color: '#000000', points: 7, type: 'color', value: 7 }
        };

        // --- 全域變數 ---
        const canvas = document.getElementById('snookerCanvas');
        const ctx = canvas.getContext('2d');
        let scaleFactor = 1;

        let balls = [];
        let pockets = [];
        let cueBall = null;

        let gameState = {
            isMoving: false,
            isAiming: true,
            isPlacingCue: true,
            currentPlayer: 1,
            scores: { 1: 0, 2: 0 },
            frames: { 1: 0, 2: 0 },
            aimAngle: 0,
            power: 50, 
            targetBall: 'red',
            pottedBalls: [],
            redsRemaining: 15,
            minColorPoints: 2
        };

        // --- 初始化 ---
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            setupInput();
            setupAccordion();
            resetGame(true); 
            requestAnimationFrame(gameLoop);
        }

        function resizeCanvas() {
            const container = document.getElementById('game-container');
            const targetRatio = TABLE_WIDTH_BASE / TABLE_HEIGHT_BASE;
            const containerRatio = container.clientWidth / container.clientHeight;

            let finalWidth, finalHeight;
            const FILL_PERCENTAGE = 0.85; 

            if (containerRatio > targetRatio) {
                finalHeight = container.clientHeight * FILL_PERCENTAGE;
                finalWidth = finalHeight * targetRatio;
            } else {
                finalWidth = container.clientWidth * FILL_PERCENTAGE;
                finalHeight = finalWidth / targetRatio;
            }

            canvas.width = finalWidth;
            canvas.height = finalHeight;
            scaleFactor = finalWidth / TABLE_WIDTH_BASE;
        }

        function resetGame(startNewMatch = false) {
            balls = [];
            
            if (startNewMatch) {
                gameState.frames = { 1: 0, 2: 0 };
            }

            gameState.isMoving = false;
            gameState.isAiming = true;
            gameState.isPlacingCue = true; // 開局需要擺球
            gameState.currentPlayer = 1;
            gameState.scores = { 1: 0, 2: 0 };
            gameState.aimAngle = 0;
            gameState.targetBall = 'red';
            gameState.pottedBalls = [];
            gameState.redsRemaining = 15;
            gameState.minColorPoints = 2;

            resetPowerBarUI(50);
            
            const w = TABLE_WIDTH_BASE;
            const h = TABLE_HEIGHT_BASE;
            
            // 定義袋口 (針對 RAIL_SIZE 微調)
            // 讓袋口中心稍微深入邊框內，確保球掉進去
            const offset = RAIL_SIZE / 2; 
            pockets = [
                { x: offset, y: offset },         
                { x: w/2, y: -5 }, // 中袋稍微突出畫面外             
                { x: w-offset, y: offset },       
                { x: offset, y: h-offset },       
                { x: w/2, y: h + 5 },             
                { x: w-offset, y: h-offset }      
            ];

            // 母球
            cueBall = createBall(-100, -100, BALL_TYPES.WHITE); 
            balls.push(cueBall);

            // V1.0.5: 修正彩球位置
            // Green: D線與半圓上方交點
            balls.push(createBall(D_LINE_X, h/2 - D_ARC_RADIUS, BALL_TYPES.GREEN)); 
            // Yellow: D線與半圓下方交點
            balls.push(createBall(D_LINE_X, h/2 + D_ARC_RADIUS, BALL_TYPES.YELLOW)); 
            // Brown: 中間
            balls.push(createBall(D_LINE_X, h/2, BALL_TYPES.BROWN));       
            
            balls.push(createBall(w * 0.5, h/2, BALL_TYPES.BLUE));
            balls.push(createBall(w * 0.75, h/2, BALL_TYPES.PINK));
            balls.push(createBall(w * 0.91, h/2, BALL_TYPES.BLACK));

            // V1.0.5: 紅球堆緊貼粉球 (間距改為 1px)
            let startX = w * 0.75 + BALL_RADIUS * 2 + 1;
            let startY = h / 2;
            for (let i = 0; i < 5; i++) {
                for (let j = 0; j <= i; j++) {
                    let x = startX + i * (BALL_RADIUS * 2 * 0.9); // 0.9 讓堆疊緊密
                    let y = startY - (i * BALL_RADIUS) + (j * BALL_RADIUS * 2);
                    balls.push(createBall(x + Math.random()*0.1, y + Math.random()*0.1, BALL_TYPES.RED));
                }
            }
            updateUI();
        }

        function createBall(x, y, typeInfo) {
            return {
                x: x, y: y,
                vx: 0, vy: 0,
                radius: BALL_RADIUS,
                color: typeInfo.color,
                points: typeInfo.points,
                type: typeInfo.type,
                value: typeInfo.value || 0,
                initialX: x, initialY: y,
                inPocket: false
            };
        }

        // --- 物理引擎 (核心修正) ---
        function gameLoop() {
            updatePhysics();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function updatePhysics() {
            if (!gameState.isMoving) return;

            let movingCount = 0;
            const steps = 8; // 增加步數以保證慢速下的精確度

            for (let s = 0; s < steps; s++) {
                balls.forEach(ball => {
                    if (ball.inPocket) return;

                    ball.x += ball.vx / steps;
                    ball.y += ball.vy / steps;

                    // 1. 袋口與進球判定 (V1.0.5 重寫)
                    let potted = false;
                    let ignoreRail = false; // 是否忽略庫邊

                    for (let p of pockets) {
                        const dx = ball.x - p.x;
                        const dy = ball.y - p.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        
                        // 進球判定
                        if (dist < POCKET_RADIUS) {
                            ball.inPocket = true;
                            ball.vx = 0; ball.vy = 0;
                            ball.x = -999; 
                            gameState.pottedBalls.push(ball);
                            potted = true;
                            break;
                        }
                        
                        // V1.0.5 關鍵邏輯: 
                        // 如果球在袋口半徑的 1.5 倍範圍內，我們認為它正在進洞
                        // 此時強制關閉庫邊碰撞，防止球被彈出
                        if (dist < POCKET_RADIUS * 1.5) {
                            ignoreRail = true;
                        }
                    }
                    if (potted) return;

                    // 2. 邊框檢測 (如果 nearPocket 則跳過)
                    if (!ignoreRail) {
                        const minX = RAIL_SIZE + ball.radius;
                        const maxX = TABLE_WIDTH_BASE - RAIL_SIZE - ball.radius;
                        const minY = RAIL_SIZE + ball.radius;
                        const maxY = TABLE_HEIGHT_BASE - RAIL_SIZE - ball.radius;

                        if (ball.x < minX) { ball.x = minX; ball.vx *= -CUSHION_RESTITUTION; }
                        if (ball.x > maxX) { ball.x = maxX; ball.vx *= -CUSHION_RESTITUTION; }
                        if (ball.y < minY) { ball.y = minY; ball.vy *= -CUSHION_RESTITUTION; }
                        if (ball.y > maxY) { ball.y = maxY; ball.vy *= -CUSHION_RESTITUTION; }
                    }
                });

                // 球間碰撞
                for (let i = 0; i < balls.length; i++) {
                    for (let j = i + 1; j < balls.length; j++) {
                        let b1 = balls[i];
                        let b2 = balls[j];
                        if (b1.inPocket || b2.inPocket) continue;
                        resolveCollision(b1, b2);
                    }
                }
            }

            // 摩擦力
            balls.forEach(ball => {
                if (ball.inPocket) return;
                ball.vx *= FRICTION;
                ball.vy *= FRICTION;
                if (Math.abs(ball.vx) < STOP_THRESHOLD) ball.vx = 0;
                if (Math.abs(ball.vy) < STOP_THRESHOLD) ball.vy = 0;
                if (ball.vx !== 0 || ball.vy !== 0) movingCount++;
            });

            if (movingCount === 0 && gameState.isMoving) {
                gameState.isMoving = false;
                handleTurnEnd();
            }
        }

        function resolveCollision(b1, b2) {
            const dx = b2.x - b1.x;
            const dy = b2.y - b1.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const minDist = b1.radius + b2.radius;

            if (dist < minDist) {
                const angle = Math.atan2(dy, dx);
                const sin = Math.sin(angle);
                const cos = Math.cos(angle);

                const vx1 = b1.vx * cos + b1.vy * sin;
                const vy1 = b1.vy * cos - b1.vx * sin;
                const vx2 = b2.vx * cos + b2.vy * sin;
                const vy2 = b2.vy * cos - b2.vx * sin;

                const vx1Final = vx2;
                const vx2Final = vx1;

                const overlap = minDist - dist;
                b1.x -= (overlap/2) * cos;
                b1.y -= (overlap/2) * sin;
                b2.x += (overlap/2) * cos;
                b2.y += (overlap/2) * sin;

                b1.vx = vx1Final * cos - vy1 * sin;
                b1.vy = vx1Final * sin + vy1 * cos;
                b2.vx = vx2Final * cos - vy2 * sin;
                b2.vy = vx2Final * sin + vy2 * cos;
            }
        }

        // --- 規則邏輯 ---
        function handleTurnEnd() {
            const potted = gameState.pottedBalls;
            let switchTurn = true;
            let score = 0;
            let foul = false;
            let foulPoints = 4;
            let frameEnded = false;

            const cuePotted = potted.find(b => b.type === 'cue');
            if (cuePotted) {
                foul = true;
                potted.forEach(b => {
                   if (b.type === 'color' && b.points > foulPoints) foulPoints = b.points;
                });
                cueBall.inPocket = false;
                cueBall.vx = 0; cueBall.vy = 0;
                cueBall.x = -100;
                gameState.isPlacingCue = true;
            }

            if (!foul) {
                if (potted.length === 0) {
                    switchTurn = true;
                } else {
                    const firstBall = potted[0];
                    if (gameState.redsRemaining > 0) {
                        if (gameState.targetBall === 'red') {
                            const wrong = potted.find(b => b.type !== 'red');
                            if (wrong) {
                                foul = true; 
                                foulPoints = Math.max(4, wrong.points);
                            } else {
                                potted.forEach(b => score += b.points);
                                gameState.redsRemaining -= potted.length;
                                gameState.targetBall = 'color';
                                switchTurn = false;
                            }
                        } else {
                            const hasRed = potted.find(b => b.type === 'red');
                            if (hasRed) { foul = true; } 
                            else {
                                potted.forEach(b => score += b.points);
                                switchTurn = false;
                                potted.forEach(b => {
                                    b.inPocket = false;
                                    b.x = b.initialX; b.y = b.initialY;
                                    b.vx = 0; b.vy = 0;
                                });
                                gameState.targetBall = 'red';
                            }
                        }
                    } else {
                        // 清彩球
                        if (firstBall.points === gameState.minColorPoints) {
                            score += firstBall.points;
                            if (gameState.minColorPoints === 7) frameEnded = true;
                            gameState.minColorPoints = getNextColorPoints(gameState.minColorPoints);
                            switchTurn = false;
                        } else {
                            foul = true;
                            foulPoints = Math.max(4, firstBall.points, gameState.minColorPoints);
                             potted.forEach(b => {
                                b.inPocket = false;
                                b.x = b.initialX; b.y = b.initialY;
                                b.vx = 0; b.vy = 0;
                            });
                        }
                    }
                }
            }

            if (foul) {
                const opponent = gameState.currentPlayer === 1 ? 2 : 1;
                gameState.scores[opponent] += foulPoints;
                switchTurn = true;
                if (gameState.redsRemaining > 0) gameState.targetBall = 'red';
                potted.forEach(b => {
                    if (b.type !== 'cue' && b.type !== 'red') {
                        b.inPocket = false;
                        b.x = b.initialX; b.y = b.initialY;
                        b.vx = 0; b.vy = 0;
                    }
                });
            } else {
                gameState.scores[gameState.currentPlayer] += score;
            }

            if (frameEnded) {
                endFrame();
                return;
            }

            if (switchTurn) {
                gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;
                if (gameState.redsRemaining > 0) gameState.targetBall = 'red';
            }

            gameState.pottedBalls = [];
            gameState.isAiming = true;
            
            resetPowerBarUI(50);
            updateUI();
        }

        function endFrame() {
            const p1 = gameState.scores[1];
            const p2 = gameState.scores[2];
            if (p1 > p2) gameState.frames[1]++;
            else gameState.frames[2]++;

            if (gameState.frames[1] === 2 || gameState.frames[2] === 2) {
                alert(`Game Over! Player ${gameState.frames[1] === 2 ? 1 : 2} Wins!`);
                resetGame(true);
            } else {
                alert(`Frame Over. Score: ${gameState.frames[1]} - ${gameState.frames[2]}`);
                resetGame(false);
            }
        }

        function getNextColorPoints(current) {
            const sequence = [2, 3, 4, 5, 6, 7];
            const idx = sequence.indexOf(current);
            return (idx >= 0 && idx < sequence.length - 1) ? sequence[idx + 1] : 999;
        }

        // --- 繪圖邏輯 ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.scale(scaleFactor, scaleFactor);

            ctx.fillStyle = COLORS.RAIL;
            ctx.fillRect(0, 0, TABLE_WIDTH_BASE, TABLE_HEIGHT_BASE);
            ctx.fillStyle = COLORS.FELT;
            ctx.fillRect(RAIL_SIZE, RAIL_SIZE, TABLE_WIDTH_BASE - RAIL_SIZE*2, TABLE_HEIGHT_BASE - RAIL_SIZE*2);

            ctx.beginPath();
            ctx.strokeStyle = "rgba(255,255,255,0.2)";
            ctx.lineWidth = 2;
            ctx.moveTo(D_LINE_X, RAIL_SIZE);
            ctx.lineTo(D_LINE_X, TABLE_HEIGHT_BASE - RAIL_SIZE);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(D_LINE_X, TABLE_HEIGHT_BASE/2, D_ARC_RADIUS, Math.PI/2, -Math.PI/2);
            ctx.stroke();

            ctx.fillStyle = COLORS.POCKET;
            pockets.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, POCKET_RADIUS, 0, Math.PI * 2);
                ctx.fill();
            });

            balls.forEach(ball => {
                if (ball.inPocket) return;
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                ctx.fillStyle = ball.color;
                ctx.fill();
                ctx.beginPath();
                ctx.arc(ball.x - 2, ball.y - 2, ball.radius/2, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
                ctx.fill();
            });

            if (gameState.isAiming && !gameState.isMoving && !gameState.isPlacingCue) {
                drawAimingGuide();
                drawCueStick();
            }

            // 放置母球時的半透明預覽
            if (gameState.isPlacingCue) {
                ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
                ctx.beginPath();
                ctx.arc(cueBall.x, cueBall.y, BALL_RADIUS, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        function drawAimingGuide() {
            const alpha = 0.2 + (gameState.power / 100) * 0.6;
            const guideLengthMult = 0.5 + (gameState.power / 100) * 1.5;

            const dx = Math.cos(gameState.aimAngle);
            const dy = Math.sin(gameState.aimAngle);
            let hitDist = 1000;
            let hitBall = null;

            for (let b of balls) {
                if (b === cueBall || b.inPocket) continue;
                const bx = b.x - cueBall.x;
                const by = b.y - cueBall.y;
                const proj = bx * dx + by * dy;
                if (proj > 0) {
                    const distSq = (bx*bx + by*by) - (proj*proj);
                    const minDist = BALL_RADIUS * 2;
                    if (distSq < minDist * minDist) {
                        const backDist = Math.sqrt(minDist*minDist - distSq);
                        const impactDist = proj - backDist;
                        if (impactDist < hitDist) {
                            hitDist = impactDist;
                            hitBall = b;
                        }
                    }
                }
            }
            
            const endX = cueBall.x + dx * hitDist;
            const endY = cueBall.y + dy * hitDist;

            ctx.save();
            ctx.globalAlpha = alpha;

            ctx.beginPath();
            ctx.strokeStyle = COLORS.GUIDE_CUE;
            ctx.setLineDash([4, 4]);
            ctx.moveTo(cueBall.x, cueBall.y);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            ctx.setLineDash([]);

            if (hitBall) {
                ctx.beginPath();
                ctx.arc(endX, endY, BALL_RADIUS, 0, Math.PI*2);
                ctx.strokeStyle = "rgba(255,255,255,0.6)";
                ctx.stroke();

                const collisionDx = hitBall.x - endX;
                const collisionDy = hitBall.y - endY;
                const len = Math.sqrt(collisionDx*collisionDx + collisionDy*collisionDy);
                const normX = collisionDx / len;
                const normY = collisionDy / len;

                const targetLineLen = 50 * guideLengthMult;

                ctx.beginPath();
                ctx.strokeStyle = COLORS.GUIDE_TARGET;
                ctx.lineWidth = 2;
                ctx.moveTo(hitBall.x, hitBall.y);
                ctx.lineTo(hitBall.x + normX * targetLineLen, hitBall.y + normY * targetLineLen);
                ctx.stroke();
            }
            ctx.restore();
        }

        function drawCueStick() {
            const stickLen = 180;
            const offset = 20 + gameState.power * 0.6;
            const dx = Math.cos(gameState.aimAngle);
            const dy = Math.sin(gameState.aimAngle);
            const startX = cueBall.x - dx * offset;
            const startY = cueBall.y - dy * offset;
            const endX = startX - dx * stickLen;
            const endY = startY - dy * stickLen;

            ctx.beginPath();
            ctx.lineWidth = 5;
            ctx.strokeStyle = COLORS.CUE_STICK;
            ctx.lineCap = 'round';
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
        }

        // --- 輸入控制 ---
        let isDraggingPower = false;

        function setupInput() {
            const touchHandler = (handler) => (e) => {
                if (e.target.tagName === 'CANVAS') e.preventDefault();
                handler(e.touches ? e.touches[0] : e);
            };

            canvas.addEventListener('mousedown', handleAimStart);
            canvas.addEventListener('touchstart', touchHandler(handleAimStart), {passive: false});

            canvas.addEventListener('mousemove', handleAimMove);
            canvas.addEventListener('touchmove', touchHandler(handleAimMove), {passive: false});

            const pBar = document.getElementById('power-bar-container');
            const updatePower = (e) => {
                if (gameState.isMoving) return;
                const rect = pBar.getBoundingClientRect();
                const clientY = e.clientY || (e.touches ? e.touches[0].clientY : 0);
                let val = rect.bottom - clientY;
                let percent = (val / rect.height) * 100;
                percent = Math.max(0, Math.min(100, percent));
                
                gameState.power = percent;
                document.getElementById('power-fill').style.height = percent + '%';
                updateFireButtonState();
            };

            const startDrag = (e) => { isDraggingPower = true; updatePower(e); };
            const endDrag = () => { isDraggingPower = false; };

            pBar.addEventListener('mousedown', startDrag);
            pBar.addEventListener('touchstart', (e) => { e.preventDefault(); startDrag(e.touches[0]); });

            window.addEventListener('mousemove', (e) => { if(isDraggingPower) updatePower(e); });
            window.addEventListener('touchmove', (e) => { if(isDraggingPower) updatePower(e); });
            window.addEventListener('mouseup', endDrag);
            window.addEventListener('touchend', endDrag);

            document.getElementById('fire-btn').addEventListener('click', shoot);

            // V1.0.5: 重設按鈕 -> 回到「擺球」狀態
            document.getElementById('reset-cue-btn').addEventListener('click', () => {
                if (!gameState.isMoving && !gameState.isPlacingCue) {
                    gameState.isPlacingCue = true;
                    // 先把球移回棕球點當作預設
                    cueBall.x = D_LINE_X;
                    cueBall.y = TABLE_HEIGHT_BASE / 2;
                    showTempMsg("請點擊 D 區放置母球");
                    updateUI(); // 更新介面以隱藏重設按鈕
                }
            });

            document.getElementById('btn-left').addEventListener('click', () => adjustAngle(-0.005));
            document.getElementById('btn-right').addEventListener('click', () => adjustAngle(0.005));

            document.getElementById('info-btn').addEventListener('click', () => {
                document.getElementById('modal-overlay').style.display = 'flex';
            });
            document.getElementById('modal-close').addEventListener('click', () => {
                document.getElementById('modal-overlay').style.display = 'none';
            });
        }

        function setupAccordion() {
            const details = document.querySelectorAll('details.version-block');
            details.forEach((targetDetail) => {
                targetDetail.addEventListener('click', () => {
                    details.forEach((d) => {
                        if (d !== targetDetail) {
                            d.removeAttribute('open');
                        }
                    });
                });
            });
        }

        function getLogicPos(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (clientX - rect.left) / scaleFactor,
                y: (clientY - rect.top) / scaleFactor
            };
        }

        function handleAimStart(e) {
            if (gameState.isMoving) return;
            const pos = getLogicPos(e.clientX, e.clientY);

            if (gameState.isPlacingCue) {
                // D區判定
                const dCenterY = TABLE_HEIGHT_BASE / 2;
                const dist = Math.sqrt(Math.pow(pos.x - D_LINE_X, 2) + Math.pow(pos.y - dCenterY, 2));
                
                if (pos.x <= D_LINE_X && dist <= D_ARC_RADIUS) {
                    let collision = false;
                    for (let b of balls) {
                        if (b === cueBall || b.inPocket) continue;
                        const distSq = Math.pow(pos.x - b.x, 2) + Math.pow(pos.y - b.y, 2);
                        if (distSq < Math.pow(BALL_RADIUS * 2 + 1, 2)) {
                            collision = true;
                            break;
                        }
                    }

                    if (collision) {
                        showTempMsg("位置重疊！", true);
                    } else {
                        cueBall.x = pos.x;
                        cueBall.y = pos.y;
                        gameState.isPlacingCue = false; 
                        updateUI();
                    }
                } else {
                    showTempMsg("請放置在 D 區半圓內", true);
                }
            } else {
                updateAimAngle(pos.x, pos.y);
            }
        }

        function handleAimMove(e) {
            if (gameState.isMoving || gameState.isPlacingCue) return;
            if (e.buttons === 1 || e.type === 'touchmove') {
                const pos = getLogicPos(e.clientX, e.clientY);
                updateAimAngle(pos.x, pos.y);
            }
        }

        function updateAimAngle(tx, ty) {
            const dx = tx - cueBall.x;
            const dy = ty - cueBall.y;
            gameState.aimAngle = Math.atan2(dy, dx);
        }

        function adjustAngle(delta) {
            if (gameState.isMoving || gameState.isPlacingCue) return;
            gameState.aimAngle += delta;
        }

        function updateFireButtonState() {
            const btn = document.getElementById('fire-btn');
            if (!gameState.isMoving && !gameState.isPlacingCue && gameState.power > 0) {
                btn.classList.add('ready');
            } else {
                btn.classList.remove('ready');
            }
        }

        function shoot() {
            if (gameState.isMoving || gameState.isPlacingCue || gameState.power <= 0) return;
            
            const force = gameState.power * FORCE_MULTIPLIER; 
            
            const dx = Math.cos(gameState.aimAngle);
            const dy = Math.sin(gameState.aimAngle);

            cueBall.vx = dx * force;
            cueBall.vy = dy * force;
            gameState.isMoving = true;
            gameState.isAiming = false;
            
            updateFireButtonState(); 
        }

        function resetPowerBarUI(defaultValue = 0) {
            gameState.power = defaultValue;
            document.getElementById('power-fill').style.height = defaultValue + '%';
            updateFireButtonState();
        }

        function showTempMsg(text, isError = false) {
            const el = document.getElementById('status-msg');
            el.innerText = text;
            el.style.color = isError ? '#ff6666' : '#66ff66';
            setTimeout(() => {
                updateUI(); 
                el.style.color = '#eee';
            }, 2000);
        }

        function updateUI() {
            document.getElementById('p1-score').innerText = gameState.scores[1];
            document.getElementById('p2-score').innerText = gameState.scores[2];
            document.getElementById('frame-score').innerText = `${gameState.frames[1]} - ${gameState.frames[2]}`;

            const sb = document.getElementById('scoreboard');
            if (gameState.currentPlayer === 1) {
                sb.classList.add('active-p1'); sb.classList.remove('active-p2');
            } else {
                sb.classList.add('active-p2'); sb.classList.remove('active-p1');
            }

            const resetBtn = document.getElementById('reset-cue-btn');
            const fireBtn = document.getElementById('fire-btn');

            let msg = "";
            if (gameState.isPlacingCue) {
                msg = `玩家 ${gameState.currentPlayer} (手中球): 請點擊 D 區放置母球`;
                resetBtn.style.display = 'none'; // 正在放置時不顯示重設按鈕(因為就在放置中)
                fireBtn.style.opacity = 0; 
            } else {
                // V1.0.5: 只有在瞄準狀態且非移動中才顯示「重新擺球」
                if (!gameState.isMoving) {
                    resetBtn.style.display = 'block';
                } else {
                    resetBtn.style.display = 'none';
                }
                fireBtn.style.opacity = 0.5; 
                
                let targetText = "";
                if (gameState.redsRemaining > 0) {
                    targetText = gameState.targetBall === 'red' ? "紅球 (1分)" : "任意彩球";
                } else {
                    const colorNames = {2:'黃',3:'綠',4:'棕',5:'藍',6:'粉',7:'黑'};
                    targetText = `${colorNames[gameState.minColorPoints]}球 (${gameState.minColorPoints}分)`;
                }
                msg = `P${gameState.currentPlayer} 回合 | 目標: ${targetText}`;
            }
            document.getElementById('status-msg').innerText = msg;
            updateFireButtonState();
        }

        init();

    </script>
</body>
</html>